import React from 'react'

function testcode() {
    const handleConfirm = async () => {
        try {
            // Group products by farmer
            const productsByFarmer = addedItem.reduce((acc, item) => {
                if (!acc[item.user]) {
                    acc[item.user] = [];
                }
                acc[item.user].push(item);
                return acc;
            }, {});
    
            // Create separate orders for each farmer
            for (const farmerId in productsByFarmer) {
                const farmerProducts = productsByFarmer[farmerId];
    
                // Update availability for each product
                for (let item of farmerProducts) {
                    const EDIT_AVAILABILITY_URL = `http://127.0.0.1:8000/agriLink/update_quantity/${item.id}`;
                    const remained = item.availability === 0 ? item.InitialAvailability - item.quantity : item.availability - item.quantity;
                    await axios.patch(EDIT_AVAILABILITY_URL, { "availability": remained });
                }
    
                // Prepare orderCropData for all items
                const orderCropDataList = await Promise.all(farmerProducts.map(async item => {
                    const { user, quantity, weight, price_per_unit, unit, image, crop_name, get_discounted_price } = item;
    
                    let formData = new FormData();
                    formData.append('user', user);
    
                    // Calculate overall quantity if product has weights
                    const totalQuantity = weight.length > 0 ?
                        weight.reduce((sum, w) => {
                            const usedWeight = w.quantity > 0 ? parseFloat(w.weight.replace('kg', '').trim()) : 0;
                            return sum + usedWeight * w.quantity;
                        }, 0) * quantity
                        : quantity;
    
                    formData.append('quantity', totalQuantity);
                    formData.append('weights', JSON.stringify(weight));
                    formData.append('price_per_unit', get_discounted_price > 0 ? get_discounted_price : price_per_unit);
                    formData.append('unit', unit);
    
                    // Handle image upload
                    if (typeof image === 'string') {
                        const response = await fetch(image);
                        const blob = await response.blob();
                        formData.append('image', blob, 'image.jpg');
                    } else {
                        formData.append('image', image, image.name || 'image.jpg');
                    }
    
                    formData.append('crop_name', crop_name);
    
                    return formData;
                }));
    
                // Post all order crops at once
                const orderCropResponses = await Promise.all(orderCropDataList.map(formData =>
                    axios.post(POST_ORDER_CROPS, formData, {
                        headers: {
                            'Content-Type': 'multipart/form-data'
                        }
                    })
                ));
    
                // Extract IDs from the responses
                const orderCropIds = orderCropResponses.map(response => response.data.id);
    
                // Post order for this farmer
                const orderResponse = await axios.post(POST_ORDER_URL, {
                    user: user?.user_id,
                    address: activatedAddress ? activatedAddress.id : null,
                    status: "Pending",
                    farmer: farmerId // Associate the order with the farmer
                });
    
                // Post order detail with orderCropIds
                const details = new FormData();
                details.append("order", orderResponse.data?.id);
                orderCropIds.forEach(id => details.append("crop", id));
    
                await axios.post(POST_ORDER_DETAIL_URL, details);
            }
    
            // Clear cart
            setAddedItem([]);
            localStorage.removeItem('cartItem');
    
        } catch (err) {
            console.log('error', err);
        }
    };

//     2. Associate Payment and Delivery Options with Farmers
// Instead of associating payment and delivery options with each product, associate them with the farmer. This ensures consistency and avoids redundancy.

// Updated Django Models:
// python
# Farmer Model
class Farmer(models.Model):
    user = models.OneToOneField(User, on_delete=models.CASCADE, related_name='farmer')
    payment_methods = models.ManyToManyField('PaymentMethod', related_name='farmers')
    delivery_options = models.ManyToManyField('DeliveryOption', related_name='farmers')

# Payment Method Model
class PaymentMethod(models.Model):
    methodType = models.CharField(max_length=100)
    contact_name = models.CharField(max_length=100, blank=True, null=True)
    contact_email = models.EmailField(blank=True, null=True)
    contact_phone = models.CharField(max_length=20, blank=True, null=True)

# Delivery Option Model
class DeliveryOption(models.Model):
    name = models.CharField(max_length=100)
    fee = models.DecimalField(max_digits=10, decimal_places=2, default=0.00, null=True, blank=True)
    duration = models.CharField(max_length=50, blank=True, null=True)

#Fetch Payment and Delivery Options for Each Farmer:
#In your frontend, fetch the payment and delivery options for each farmer when the buyer confirms the order.

const fetchFarmerOptions = async (farmerId) => {
    try {
        const paymentResponse = await axios.get(`http://127.0.0.1:8000/agriLink/list_payment_methods/${farmerId}`);
        const deliveryResponse = await axios.get(`http://127.0.0.1:8000/agriLink/delivery_list/${farmerId}`);

        return {
            paymentMethods: paymentResponse.data.payment_method,
            deliveryOptions: deliveryResponse.data.delivery_options,
        };
    } catch (err) {
        console.error('Error fetching farmer options:', err);
        return { paymentMethods: [], deliveryOptions: [] };
    }
};

#3. Update Checkout Logic
#When confirming the order, fetch the payment and delivery options for each farmer and include them in the order creation process.

#Example:
const handleConfirm = async () => {
    try {
        // Group products by farmer
        const productsByFarmer = addedItem.reduce((acc, item) => {
            if (!acc[item.user]) {
                acc[item.user] = [];
            }
            acc[item.user].push(item);
            return acc;
        }, {});

        // Create separate orders for each farmer
        for (const farmerId in productsByFarmer) {
            const farmerProducts = productsByFarmer[farmerId];

            // Fetch payment and delivery options for this farmer
            const { paymentMethods, deliveryOptions } = await fetchFarmerOptions(farmerId);

            // Update availability for each product
            for (let item of farmerProducts) {
                const EDIT_AVAILABILITY_URL = `http://127.0.0.1:8000/agriLink/update_quantity/${item.id}`;
                const remained = item.availability === 0 ? item.InitialAvailability - item.quantity : item.availability - item.quantity;
                await axios.patch(EDIT_AVAILABILITY_URL, { "availability": remained });
            }

            // Prepare orderCropData for all items
            const orderCropDataList = await Promise.all(farmerProducts.map(async item => {
                const { user, quantity, weight, price_per_unit, unit, image, crop_name, get_discounted_price } = item;

                let formData = new FormData();
                formData.append('user', user);

                // Calculate overall quantity if product has weights
                const totalQuantity = weight.length > 0 ?
                    weight.reduce((sum, w) => {
                        const usedWeight = w.quantity > 0 ? parseFloat(w.weight.replace('kg', '').trim()) : 0;
                        return sum + usedWeight * w.quantity;
                    }, 0) * quantity
                    : quantity;

                formData.append('quantity', totalQuantity);
                formData.append('weights', JSON.stringify(weight));
                formData.append('price_per_unit', get_discounted_price > 0 ? get_discounted_price : price_per_unit);
                formData.append('unit', unit);

                // Handle image upload
                if (typeof image === 'string') {
                    const response = await fetch(image);
                    const blob = await response.blob();
                    formData.append('image', blob, 'image.jpg');
                } else {
                    formData.append('image', image, image.name || 'image.jpg');
                }

                formData.append('crop_name', crop_name);

                return formData;
            }));

            // Post all order crops at once
            const orderCropResponses = await Promise.all(orderCropDataList.map(formData =>
                axios.post(POST_ORDER_CROPS, formData, {
                    headers: {
                        'Content-Type': 'multipart/form-data'
                    }
                })
            ));

            // Extract IDs from the responses
            const orderCropIds = orderCropResponses.map(response => response.data.id);

            // Post order for this farmer
            const orderResponse = await axios.post(POST_ORDER_URL, {
                user: user?.user_id,
                address: activatedAddress ? activatedAddress.id : null,
                status: "Pending",
                farmer: farmerId, // Associate the order with the farmer
                payment_method: paymentMethods[0]?.id, // Use the first payment method
                delivery_option: deliveryOptions[0]?.id // Use the first delivery option
            });

            // Post order detail with orderCropIds
            const details = new FormData();
            details.append("order", orderResponse.data?.id);
            orderCropIds.forEach(id => details.append("crop", id));

            await axios.post(POST_ORDER_DETAIL_URL, details);
        }

        // Clear cart
        setAddedItem([]);
        localStorage.removeItem('cartItem');

    } catch (err) {
        console.log('error', err);
    }
};


  return (
    <div>
      
    </div>
  )
}

export default testcode
